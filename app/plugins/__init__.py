from __future__ import annotations

import dataclasses
import time
from dataclasses import dataclass, field
from typing import Any, Callable, ClassVar, Dict, Iterable, List, Mapping, MutableMapping, Optional, Sequence, Tuple, Type, TypeVar

from ..export_manifest import build_manifest
from ..services.workspace import WorkspaceService
from ..ui.controller import OverlayTrace

__all__ = [
    "PluginContext",
    "PluginError",
    "PluginField",
    "PluginResult",
    "PluginTable",
    "PluginBase",
    "PluginRegistry",
    "plugin_registry",
]


class PluginError(RuntimeError):
    """Raised when plugin execution fails."""


@dataclass(frozen=True)
class PluginField:
    """Description for a configuration widget rendered by the UI."""

    name: str
    label: str
    kind: str = "float"
    default: Any = None
    options: Sequence[Any] = ()
    min_value: float | None = None
    max_value: float | None = None
    step: float | None = None
    help: str | None = None


@dataclass(frozen=True)
class PluginTable:
    """Tabular output generated by a plugin run."""

    name: str
    rows: Sequence[Mapping[str, Any]]
    description: str | None = None


@dataclass(frozen=True)
class PluginResult:
    """Container returned from a plugin run."""

    overlays: Sequence[Mapping[str, object]] = ()
    tables: Sequence[PluginTable] = ()
    messages: Sequence[str] = ()
    provenance: Mapping[str, Any] = field(default_factory=dict)


@dataclass
class PluginContext:
    """Runtime helpers available to plugins."""

    workspace: WorkspaceService
    overlays: Sequence[OverlayTrace]

    def list_overlays(self, *, include_hidden: bool = False) -> List[OverlayTrace]:
        if include_hidden:
            return [dataclasses.replace(trace) for trace in self.overlays]
        return [
            dataclasses.replace(trace)
            for trace in self.overlays
            if trace.visible
        ]

    def get_overlay(self, trace_id: str) -> OverlayTrace | None:
        for trace in self.overlays:
            if trace.trace_id == trace_id:
                return dataclasses.replace(trace)
        return None

    def build_manifest(
        self,
        rows: Sequence[Mapping[str, Any]],
        *,
        display_units: str,
        display_mode: str = "Flux (raw)",
        viewport: Mapping[str, Tuple[float | None, float | None]] | None = None,
    ) -> Mapping[str, Any]:
        viewport_payload = None
        if viewport:
            viewport_payload = {
                kind: {"low": bounds[0], "high": bounds[1]}
                for kind, bounds in viewport.items()
            }
        return build_manifest(
            rows,
            display_units=display_units,
            display_mode=display_mode,
            exported_at=time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()),
            viewport=viewport_payload or {},
        )


P = TypeVar("P", bound="PluginBase")


class PluginRegistry:
    """In-memory registry of available plugins."""

    def __init__(self) -> None:
        self._registry: Dict[str, Type[PluginBase]] = {}

    def register(self, plugin_cls: Type[P]) -> Type[P]:
        identifier = getattr(plugin_cls, "plugin_id", None)
        if not identifier:
            raise ValueError("Plugins must define a non-empty plugin_id.")
        key = str(identifier).strip().lower()
        if key in self._registry:
            raise ValueError(f"Duplicate plugin identifier '{identifier}'.")
        self._registry[key] = plugin_cls
        return plugin_cls

    def get(self, plugin_id: str) -> Type[PluginBase]:
        key = str(plugin_id or "").strip().lower()
        if not key:
            raise KeyError("Plugin identifier cannot be empty.")
        try:
            return self._registry[key]
        except KeyError as exc:
            raise KeyError(f"Unknown plugin '{plugin_id}'.") from exc

    def list_plugins(self) -> List[Type[PluginBase]]:
        return sorted(self._registry.values(), key=lambda cls: cls.label.lower())


class PluginBase:
    """Base class implemented by all plugins."""

    plugin_id: ClassVar[str]
    label: ClassVar[str]
    description: ClassVar[str] = ""
    selection_mode: ClassVar[str] = "single"  # or "multiple"

    def __init__(self, context: PluginContext):
        self._context = context

    @property
    def context(self) -> PluginContext:
        return self._context

    def config_fields(self) -> Sequence[PluginField]:
        return ()

    def supports_selection(self) -> bool:
        return True

    def default_selection(self) -> Sequence[str]:
        overlays = self.context.list_overlays()
        if not overlays:
            return ()
        if self.selection_mode == "multiple":
            return tuple(trace.trace_id for trace in overlays)
        return (overlays[0].trace_id,)

    def execute(
        self,
        selection: Sequence[str],
        config: Mapping[str, Any],
    ) -> PluginResult:
        raise NotImplementedError

    # ------------------------------------------------------------------
    # Provenance helpers
    # ------------------------------------------------------------------
    def build_provenance(
        self,
        *,
        selection: Sequence[str],
        parameters: Mapping[str, Any],
        extras: Mapping[str, Any] | None = None,
    ) -> Dict[str, Any]:
        payload = {
            "plugin": {
                "id": self.plugin_id,
                "label": self.label,
                "selection": list(selection),
                "parameters": {
                    key: self._serialize_parameter(value)
                    for key, value in parameters.items()
                },
            }
        }
        if extras:
            payload["plugin"].update({str(k): v for k, v in extras.items()})
        return payload

    @staticmethod
    def _serialize_parameter(value: Any) -> Any:
        if isinstance(value, (list, tuple)):
            return [PluginBase._serialize_parameter(item) for item in value]
        if isinstance(value, dict):
            return {
                str(key): PluginBase._serialize_parameter(val)
                for key, val in value.items()
            }
        if hasattr(value, "to_value"):
            try:
                return value.to_value()
            except Exception:  # pragma: no cover - defensive
                return str(value)
        return value


plugin_registry = PluginRegistry()
